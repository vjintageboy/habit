**IMPORTANT: Return ONLY the two code files. No explanations, no commentary, just the code.**

I am customizing an IOTA dApp built with Next.js, React, and TypeScript. Update the contract integration hook and UI component.

## Contract Details

- **Network:** `devnet`
- **Package ID:** `0x1ea19db6bde0cc6fb9fa6caae905138e38da6729580703e228237ba031380aa2`
- **Module Name:** `contract`
- **Available Methods:**

  * `create_habit` (constant: `CREATE_HABIT`)
  * `check_in` (constant: `CHECK_IN`)
  * `update_habit` (constant: `UPDATE_HABIT`)
  * `delete_habit` (constant: `DELETE_HABIT`)
  * `get_habit_info` (constant: `GET_HABIT_INFO`)
  * `get_completion_rate` (constant: `GET_COMPLETION_RATE`)
  * `can_check_in_today` (constant: `CAN_CHECK_IN_TODAY`)
  * `get_days_since_creation` (constant: `GET_DAYS_SINCE_CREATION`)

---

# **Move Contract: `contract/habit/sources/habit.move`**

```move
module habit::contract {
use iota::object::{Self, UID, ID};
use iota::tx_context::{Self, TxContext};
use iota::transfer;
use iota::event;
use std::string::{Self, String};
use std::option;
const E_ALREADY_CHECKED_IN: u64 = 1;
const E_NOT_OWNER: u64 = 2;
const E_INVALID_DATE: u64 = 3;
const E_INVALID_GOAL_TYPE: u64 = 4;
const GOAL_TYPE_MONTHLY: u8 = 2;
const MS_PER_DAY: u64 = 86400000;
public struct Habit has key {
id: UID,
owner: address,
name: String,
description: String,
emoji: String,
created_at: u64,
goal_type: u8,
goal_count: u64,
total_checkins: u64,
current_streak: u64,
longest_streak: u64,
last_checkin_date: Option<u64>,
is_public: bool,
}
public struct CheckIn has key {
id: UID,
habit_id: ID,
date: u64,
notes: Option<String>,
}
public struct HabitCreated has copy, drop {
habit_id: ID,
owner: address,
name: String,
}
public struct CheckInRecorded has copy, drop {
habit_id: ID,
date: u64,
new_streak: u64,
total_checkins: u64,
}
public struct StreakBroken has copy, drop {
habit_id: ID,
previous_streak: u64,
}
public struct HabitUpdated has copy, drop {
habit_id: ID,
}
public struct HabitDeleted has copy, drop {
habit_id: ID,
}
public entry fun create_habit(
name: vector<u8>,
description: vector<u8>,
emoji: vector<u8>,
goal_type: u8,
goal_count: u64,
is_public: bool,
ctx: &mut TxContext
): ID {
assert!(goal_type <= GOAL_TYPE_MONTHLY, E_INVALID_GOAL_TYPE);
let habit = Habit {
id: object::new(ctx),
owner: ctx.sender(),
name: string::utf8(name),
description: string::utf8(description),
emoji: string::utf8(emoji),
created_at: tx_context::epoch_timestamp_ms(ctx),
goal_type,
goal_count,
total_checkins: 0,
current_streak: 0,
longest_streak: 0,
last_checkin_date: option::none(),
is_public,
};
let habit_id = object::id(&habit);
transfer::share_object(habit);
event::emit(HabitCreated {
habit_id,
owner: ctx.sender(),
name: string::utf8(name),
});
habit_id
}
public entry fun check_in(
habit: &mut Habit,
notes: vector<u8>,
ctx: &mut TxContext
) {
let now = tx_context::epoch_timestamp_ms(ctx);
let today = get_date_timestamp(now);
if (option::is_some(&habit.last_checkin_date)) {
let last_date = *option::borrow(&habit.last_checkin_date);
assert!(last_date != today, E_ALREADY_CHECKED_IN);
};
let yesterday = today - MS_PER_DAY;
if (option::is_some(&habit.last_checkin_date)) {
let last_date = *option::borrow(&habit.last_checkin_date);
if (last_date == yesterday) {
habit.current_streak = habit.current_streak + 1;
} else if (last_date < yesterday) {
if (habit.current_streak > habit.longest_streak) {
habit.longest_streak = habit.current_streak;
};
let previous_streak = habit.current_streak;
habit.current_streak = 1;
event::emit(StreakBroken {
habit_id: object::id(habit),
previous_streak,
});
} else {
abort E_INVALID_DATE
}
} else {
habit.current_streak = 1;
};
habit.total_checkins = habit.total_checkins + 1;
habit.last_checkin_date = option::some(today);
if (habit.current_streak > habit.longest_streak) {
habit.longest_streak = habit.current_streak;
};
let notes_option = if (vector::length(&notes) > 0) {
option::some(string::utf8(notes))
} else {
option::none()
};
let checkin = CheckIn {
id: object::new(ctx),
habit_id: object::id(habit),
date: today,
notes: notes_option,
};
transfer::transfer(checkin, ctx.sender());
event::emit(CheckInRecorded {
habit_id: object::id(habit),
date: today,
new_streak: habit.current_streak,
total_checkins: habit.total_checkins,
});
}
public entry fun update_habit(
habit: &mut Habit,
name: Option<String>,
description: Option<String>,
emoji: Option<String>,
goal_type: Option<u8>,
goal_count: Option<u64>,
is_public: Option<bool>,
ctx: &TxContext
) {
assert!(habit.owner == ctx.sender(), E_NOT_OWNER);
if (option::is_some(&name)) {
habit.name = *option::borrow(&name);
};
if (option::is_some(&description)) {
habit.description = *option::borrow(&description);
};
if (option::is_some(&emoji)) {
habit.emoji = *option::borrow(&emoji);
};
if (option::is_some(&goal_type)) {
let gt = *option::borrow(&goal_type);
assert!(gt <= GOAL_TYPE_MONTHLY, E_INVALID_GOAL_TYPE);
habit.goal_type = gt;
};
if (option::is_some(&goal_count)) {
habit.goal_count = *option::borrow(&goal_count);
};
if (option::is_some(&is_public)) {
habit.is_public = *option::borrow(&is_public);
};
event::emit(HabitUpdated {
habit_id: object::id(habit),
});
}
public entry fun delete_habit(habit: Habit, ctx: &TxContext) {
assert!(habit.owner == ctx.sender(), E_NOT_OWNER);
let habit_id = object::id(&habit);
let Habit { id, .. } = habit;
object::delete(id);
event::emit(HabitDeleted {
habit_id,
});
}
public fun get_habit_info(habit: &Habit): (
address,
String,
String,
String,
u64,
u8,
u64,
u64,
u64,
u64,
bool
) {
(
habit.owner,
habit.name,
habit.description,
habit.emoji,
habit.created_at,
habit.goal_type,
habit.goal_count,
habit.total_checkins,
habit.current_streak,
habit.longest_streak,
habit.is_public,
)
}
public fun get_completion_rate(habit: &Habit, period_days: u64): u64 {
if (habit.total_checkins == 0 || period_days == 0) {
return 0
};
let expected = period_days * habit.goal_count;
if (expected == 0) {
return 0
};
let rate = (habit.total_checkins * 100) / expected;
if (rate > 100) {
100
} else {
rate
}
}
public fun can_check_in_today(habit: &Habit, ctx: &TxContext): bool {
let now = tx_context::epoch_timestamp_ms(ctx);
let today = get_date_timestamp(now);
if (option::is_some(&habit.last_checkin_date)) {
let last_date = *option::borrow(&habit.last_checkin_date);
last_date != today
} else {
true
}
}
fun get_date_timestamp(timestamp_ms: u64): u64 {
timestamp_ms - (timestamp_ms % MS_PER_DAY)
}
public fun get_days_since_creation(habit: &Habit, ctx: &TxContext): u64 {
let now = tx_context::epoch_timestamp_ms(ctx);
let created = get_date_timestamp(habit.created_at);
let current = get_date_timestamp(now);
if (current < created) {
return 0
};
(current - created) / MS_PER_DAY
}
}
```

---

# File 1: `hooks/useContract.ts`

```ts
"use client"

/**
 * ============================================================================
 * IOTA CONTRACT INTEGRATION HOOK
 * ============================================================================
 * 
 * This hook contains ALL the contract interaction logic.
 * 
 * To customize your dApp, modify the configuration section below.
 * 
 * ============================================================================
 */

import { useState, useEffect } from "react"
import {
  useCurrentAccount,
  useIotaClient,
  useSignAndExecuteTransaction,
  useIotaClientQuery,
} from "@iota/dapp-kit"
import { Transaction } from "@iota/iota-sdk/transactions"
import { useNetworkVariable } from "@/lib/config"
import type { IotaObjectData } from "@iota/iota-sdk/client"

// ============================================================================
// CONTRACT CONFIGURATION
// ============================================================================
// Change these values to match your Move contract

export const CONTRACT_MODULE = "contract" // Your Move module name
export const CONTRACT_METHODS = {
  CREATE: "create",
  INCREMENT: "increment",
  SET_VALUE: "set_value",
} as const

// ============================================================================
// DATA EXTRACTION
// ============================================================================
// Modify this to extract data from your contract's object structure

function getObjectFields(data: IotaObjectData): { value: number; owner: string } | null {
  if (data.content?.dataType !== "moveObject") {
    console.log("Data is not a moveObject:", data.content?.dataType)
    return null
  }
  
  const fields = data.content.fields as any
  if (!fields) {
    console.log("No fields found in object data")
    return null
  }
  
  // Log the actual structure for debugging
  console.log("Object fields structure:", JSON.stringify(fields, null, 2))
  
  // Handle value - it might be a string (u64) or number
  let value: number
  if (typeof fields.value === "string") {
    value = parseInt(fields.value, 10)
    if (isNaN(value)) {
      console.log("Value is not a valid number:", fields.value)
      return null
    }
  } else if (typeof fields.value === "number") {
    value = fields.value
  } else {
    console.log("Value is not a number or string:", typeof fields.value, fields.value)
    return null
  }
  
  // Handle owner - convert to string
  if (!fields.owner) {
    console.log("Owner field is missing")
    return null
  }
  
  const owner = String(fields.owner)
  
  return {
    value,
    owner,
  }
}

// ============================================================================
// MAIN HOOK
// ============================================================================

export interface ContractData {
  value: number
  owner: string
}

export interface ContractState {
  isLoading: boolean
  isPending: boolean
  isConfirming: boolean
  isConfirmed: boolean
  hash: string | undefined
  error: Error | null
}

export interface ContractActions {
  createObject: () => Promise<void>
  increment: () => Promise<void>
  reset: () => Promise<void>
  clearObject: () => void
}

export const useContract = () => {
  const currentAccount = useCurrentAccount()
  const address = currentAccount?.address
  const packageId = useNetworkVariable("packageId")
  const iotaClient = useIotaClient()
  const { mutate: signAndExecute, isPending } = useSignAndExecuteTransaction()
  const [objectId, setObjectId] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hash, setHash] = useState<string | undefined>()
  const [transactionError, setTransactionError] = useState<Error | null>(null)

  // Load object ID from URL hash
  useEffect(() => {
    if (typeof window !== "undefined") {
      const hash = window.location.hash.slice(1)
      if (hash) setObjectId(hash)
    }
  }, [])

  // Fetch object data
  const { data, isPending: isFetching, error: queryError, refetch } = useIotaClientQuery(
    "getObject",
    {
      id: objectId!,
      options: { showContent: true, showOwner: true },
    },
    {
      enabled: !!objectId,
    }
  )

  // Extract fields
  const fields = data?.data ? getObjectFields(data.data) : null
  const isOwner = fields?.owner.toLowerCase() === address?.toLowerCase()
  
  // Check if object exists but data extraction failed
  const objectExists = !!data?.data
  const hasValidData = !!fields

  // Create object
  const createObject = async () => {
    if (!packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      setHash(undefined)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.CREATE}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              })
              const newObjectId = effects?.created?.[0]?.reference?.objectId
              if (newObjectId) {
                setObjectId(newObjectId)
                if (typeof window !== "undefined") {
                  window.location.hash = newObjectId
                }
                // Reset loading - the query will handle its own loading state
                setIsLoading(false)
              } else {
                setIsLoading(false)
                console.warn("No object ID found in transaction effects")
              }
            } catch (waitError) {
              console.error("Error waiting for transaction:", waitError)
              setIsLoading(false)
            }
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("Error:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("Error creating object:", err)
      setIsLoading(false)
    }
  }

  // Increment
  const increment = async () => {
    if (!objectId || !packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [tx.object(objectId)],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.INCREMENT}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            await iotaClient.waitForTransaction({ digest })
            await refetch()
            setIsLoading(false)
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("Error:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("Error incrementing:", err)
      setIsLoading(false)
    }
  }

  // Reset
  const reset = async () => {
    if (!objectId || !packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [tx.object(objectId), tx.pure.u64(0)],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.SET_VALUE}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            await iotaClient.waitForTransaction({ digest })
            await refetch()
            setIsLoading(false)
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("Error:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("Error resetting:", err)
      setIsLoading(false)
    }
  }

  const contractData: ContractData | null = fields
    ? {
        value: fields.value,
        owner: fields.owner,
      }
    : null

  const clearObject = () => {
    setObjectId(null)
    setTransactionError(null)
    if (typeof window !== "undefined") {
      window.location.hash = ""
    }
  }

  const actions: ContractActions = {
    createObject,
    increment,
    reset,
    clearObject,
  }

  const contractState: ContractState = {
    isLoading: (isLoading && !objectId) || isPending || isFetching,
    isPending,
    isConfirming: false,
    isConfirmed: !!hash && !isLoading && !isPending,
    hash,
    error: queryError || transactionError,
  }

  return {
    data: contractData,
    actions,
    state: contractState,
    objectId,
    isOwner,
    objectExists,
    hasValidData,
  }
}


```

---

# File 2: `components/sample.tsx`

```tsx
"use client"

/**
 * ============================================================================
 * IOTA DAPP INTEGRATION COMPONENT
 * ============================================================================
 * 
 * This is the main integration component for your IOTA dApp.
 * 
 * All the contract logic is in hooks/useContract.ts
 * 
 * To customize your dApp, modify this file.
 * 
 * ============================================================================
 */

import { useCurrentAccount } from "@iota/dapp-kit"
import { useContract } from "@/hooks/useContract"
import { Button, Container, Flex, Heading, Text } from "@radix-ui/themes"
import ClipLoader from "react-spinners/ClipLoader"

const SampleIntegration = () => {
  const currentAccount = useCurrentAccount()
  const { data, actions, state, objectId, isOwner, objectExists, hasValidData } = useContract()
  
  const isConnected = !!currentAccount

  if (!isConnected) {
    return (
      <div style={{ minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center", padding: "1rem" }}>
        <div style={{ maxWidth: "500px", width: "100%" }}>
          <Heading size="6" style={{ marginBottom: "1rem" }}>IOTA dApp</Heading>
          <Text>Please connect your wallet to interact with the contract.</Text>
        </div>
      </div>
    )
  }

  return (
    <div style={{ minHeight: "100vh", padding: "1rem", background: "var(--gray-a2)" }}>
      <Container style={{ maxWidth: "800px", margin: "0 auto" }}>
        <Heading size="6" style={{ marginBottom: "2rem" }}>IOTA Counter dApp</Heading>

        {!objectId ? (
          <div>
            <Button
              size="3"
              onClick={actions.createObject}
              disabled={state.isPending}
            >
              {state.isPending ? (
                <>
                  <ClipLoader size={16} style={{ marginRight: "8px" }} />
                  Creating...
                </>
              ) : (
                "Create Counter"
              )}
            </Button>
            {state.error && (
              <div style={{ marginTop: "1rem", padding: "1rem", background: "var(--red-a3)", borderRadius: "8px" }}>
                <Text style={{ color: "var(--red-11)" }}>
                  Error: {(state.error as Error)?.message || String(state.error)}
                </Text>
              </div>
            )}
          </div>
        ) : (
          <div>
            {state.isLoading && !data ? (
              <Text>Loading object...</Text>
            ) : state.error ? (
              <div style={{ padding: "1rem", background: "var(--red-a3)", borderRadius: "8px" }}>
                <Text style={{ color: "var(--red-11)", display: "block", marginBottom: "0.5rem" }}>
                  Error loading object
                </Text>
                <Text size="2" style={{ color: "var(--red-11)" }}>
                  {state.error.message || "Object not found or invalid"}
                </Text>
                <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.5rem", display: "block" }}>
                  Object ID: {objectId}
                </Text>
                <Button
                  size="2"
                  variant="soft"
                  onClick={actions.clearObject}
                  style={{ marginTop: "1rem" }}
                >
                  Clear & Create New
                </Button>
              </div>
            ) : objectExists && !hasValidData ? (
              <div style={{ padding: "1rem", background: "var(--yellow-a3)", borderRadius: "8px" }}>
                <Text style={{ color: "var(--yellow-11)" }}>
                  Object found but data structure is invalid. Please check the contract structure.
                </Text>
                <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.5rem", display: "block" }}>
                  Object ID: {objectId}
                </Text>
              </div>
            ) : data ? (
              <div>
                <div style={{ marginBottom: "1rem", padding: "1rem", background: "var(--gray-a3)", borderRadius: "8px" }}>
                  <Text size="2" style={{ display: "block", marginBottom: "0.5rem" }}>Counter Value</Text>
                  <Heading size="8">{data.value}</Heading>
                  <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.5rem", display: "block" }}>
                    Object ID: {objectId}
                  </Text>
                </div>

                <Flex gap="2" style={{ marginBottom: "1rem" }}>
                  <Button
                    onClick={actions.increment}
                    disabled={state.isLoading || state.isPending}
                  >
                    {state.isLoading || state.isPending ? (
                      <ClipLoader size={16} />
                    ) : (
                      "Increment"
                    )}
                  </Button>
                  {isOwner && (
                    <Button
                      onClick={actions.reset}
                      disabled={state.isLoading || state.isPending}
                    >
                      {state.isLoading || state.isPending ? (
                        <ClipLoader size={16} />
                      ) : (
                        "Reset"
                      )}
                    </Button>
                  )}
                </Flex>

                {state.hash && (
                  <div style={{ marginTop: "1rem", padding: "1rem", background: "var(--gray-a3)", borderRadius: "8px" }}>
                    <Text size="1" style={{ display: "block", marginBottom: "0.5rem" }}>Transaction Hash</Text>
                    <Text size="2" style={{ fontFamily: "monospace", wordBreak: "break-all" }}>{state.hash}</Text>
                    {state.isConfirmed && (
                      <Text size="2" style={{ color: "green", marginTop: "0.5rem", display: "block" }}>
                        Transaction confirmed!
                      </Text>
                    )}
                  </div>
                )}

                {state.error && (
                  <div style={{ marginTop: "1rem", padding: "1rem", background: "var(--red-a3)", borderRadius: "8px" }}>
                    <Text style={{ color: "var(--red-11)" }}>
                      Error: {(state.error as Error)?.message || String(state.error)}
                    </Text>
                  </div>
                )}
              </div>
            ) : (
              <div style={{ padding: "1rem", background: "var(--yellow-a3)", borderRadius: "8px" }}>
                <Text style={{ color: "var(--yellow-11)" }}>Object not found</Text>
                <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.5rem", display: "block" }}>
                  Object ID: {objectId}
                </Text>
                <Button
                  size="2"
                  variant="soft"
                  onClick={actions.clearObject}
                  style={{ marginTop: "1rem" }}
                >
                  Clear & Create New
                </Button>
              </div>
            )}
          </div>
        )}
      </Container>
    </div>
  )
}

export default SampleIntegration

```

---

# Your Task

Return **two updated files**:

## 1. `hooks/useContract.ts`

- Keep all TypeScript interfaces
- Preserve loading, error, and transaction state logic
- Maintain hook object structure
- Keep contract calls functional
- Use Package ID: `0x1ea19db6bde0cc6fb9fa6caae905138e38da6729580703e228237ba031380aa2` and Module: `contract`
- Only implement requested changes

## 2. `components/sample.tsx`

- Keep UI behavior and wallet checks
- Preserve loading, error, object state and transaction UI
- Maintain interaction logic unless specified
- Apply only requested modifications
